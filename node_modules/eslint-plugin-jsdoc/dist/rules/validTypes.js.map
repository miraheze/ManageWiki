{"version":3,"sources":["../../src/rules/validTypes.js"],"names":["asExpression","jsdoc","report","utils","context","settings","allowEmptyNamepaths","options","mode","tryParseIgnoreError","path","tags","forEach","tag","validNamepathParsing","namepath","tagName","handled","startsWith","endChar","slice","includes","startChar","charAt","validTypeParsing","type","thisNamepath","getTagDescription","replace","trim","test","thatNamepath","name","otherModeMaps","filter","mde","map","getTagStructureForMode","tagMightHaveNamePosition","modeInfo","mightHaveTypePosition","tagMightHaveTypePosition","tagMustHaveNamePosition","mustHaveTypePosition","tagMustHaveTypePosition","tagMissingRequiredTypeOrNamepath","hasTypePosition","Boolean","hasNameOrNamepathPosition","tagMightHaveNamepath","parseClosureTemplateTag","iterateAllJsdocs","meta","docs","description","url","schema","additionalProperies","properties","default"],"mappings":"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","sourcesContent":["import {\n  parse,\n} from 'jsdoctypeparser';\nimport iterateJsdoc from '../iterateJsdoc';\n\nconst asExpression = /as\\s+/u;\n\nexport default iterateJsdoc(({\n  jsdoc,\n  report,\n  utils,\n  context,\n  settings,\n}) => {\n  const {\n    allowEmptyNamepaths = false,\n  } = context.options[0] || {};\n  const {mode} = settings;\n\n  const tryParseIgnoreError = (path) => {\n    try {\n      parse(path, {mode});\n\n      return true;\n    } catch {\n      // Keep the original error for including the whole type\n    }\n\n    return false;\n  };\n\n  // eslint-disable-next-line complexity\n  jsdoc.tags.forEach((tag) => {\n    const validNamepathParsing = function (namepath, tagName) {\n      if (tryParseIgnoreError(namepath)) {\n        return true;\n      }\n      let handled = false;\n\n      if (tagName) {\n        switch (tagName) {\n        case 'module': {\n          if (!namepath.startsWith('module:')) {\n            handled = tryParseIgnoreError(`module:${namepath}`);\n          }\n          break;\n        }\n        case 'memberof': case 'memberof!': {\n          const endChar = namepath.slice(-1);\n          if (['#', '.', '~'].includes(endChar)) {\n            handled = tryParseIgnoreError(namepath.slice(0, -1));\n          }\n          break;\n        }\n        case 'borrows': {\n          const startChar = namepath.charAt();\n          if (['#', '.', '~'].includes(startChar)) {\n            handled = tryParseIgnoreError(namepath.slice(1));\n          }\n        }\n        }\n      }\n\n      if (!handled) {\n        report(`Syntax error in namepath: ${namepath}`, null, tag);\n\n        return false;\n      }\n\n      return true;\n    };\n\n    const validTypeParsing = function (type) {\n      try {\n        parse(type, {mode});\n      } catch {\n        report(`Syntax error in type: ${type}`, null, tag);\n\n        return false;\n      }\n\n      return true;\n    };\n\n    if (tag.tag === 'borrows') {\n      const thisNamepath = utils.getTagDescription(tag).replace(asExpression, '').trim();\n\n      if (!asExpression.test(utils.getTagDescription(tag)) || !thisNamepath) {\n        report(`@borrows must have an \"as\" expression. Found \"${utils.getTagDescription(tag)}\"`, null, tag);\n\n        return;\n      }\n\n      if (validNamepathParsing(thisNamepath, 'borrows')) {\n        const thatNamepath = tag.name;\n\n        validNamepathParsing(thatNamepath);\n      }\n\n      return;\n    }\n\n    const otherModeMaps = ['jsdoc', 'typescript', 'closure', 'permissive'].filter(\n      (mde) => {\n        return mde !== mode;\n      },\n    ).map((mde) => {\n      return utils.getTagStructureForMode(mde);\n    });\n\n    const tagMightHaveNamePosition = utils.tagMightHaveNamePosition(tag.tag, otherModeMaps);\n    if (tagMightHaveNamePosition !== true && tag.name) {\n      const modeInfo = tagMightHaveNamePosition === false ? '' : ` in \"${mode}\" mode`;\n      report(`@${tag.tag} should not have a name${modeInfo}.`, null, tag);\n\n      return;\n    }\n\n    const mightHaveTypePosition = utils.tagMightHaveTypePosition(tag.tag, otherModeMaps);\n    if (mightHaveTypePosition !== true && tag.type) {\n      const modeInfo = mightHaveTypePosition === false ? '' : ` in \"${mode}\" mode`;\n      report(`@${tag.tag} should not have a bracketed type${modeInfo}.`, null, tag);\n\n      return;\n    }\n\n    // REQUIRED NAME\n    const tagMustHaveNamePosition = utils.tagMustHaveNamePosition(tag.tag, otherModeMaps);\n\n    // Don't handle `@param` here though it does require name as handled by\n    //  `require-param-name` (`@property` would similarly seem to require one,\n    //  but is handled by `require-property-name`)\n    if (tagMustHaveNamePosition !== false && !tag.name && !allowEmptyNamepaths && ![\n      'param', 'arg', 'argument',\n      'property', 'prop',\n    ].includes(tag.tag) &&\n      (tag.tag !== 'see' || !utils.getTagDescription(tag).includes('{@link'))\n    ) {\n      const modeInfo = tagMustHaveNamePosition === true ? '' : ` in \"${mode}\" mode`;\n      report(`Tag @${tag.tag} must have a name/namepath${modeInfo}.`, null, tag);\n\n      return;\n    }\n\n    // REQUIRED TYPE\n    const mustHaveTypePosition = utils.tagMustHaveTypePosition(tag.tag, otherModeMaps);\n    if (mustHaveTypePosition !== false && !tag.type) {\n      const modeInfo = mustHaveTypePosition === true ? '' : ` in \"${mode}\" mode`;\n      report(`Tag @${tag.tag} must have a type${modeInfo}.`, null, tag);\n\n      return;\n    }\n\n    // REQUIRED TYPE OR NAME/NAMEPATH\n    const tagMissingRequiredTypeOrNamepath = utils.tagMissingRequiredTypeOrNamepath(tag, otherModeMaps);\n    if (tagMissingRequiredTypeOrNamepath !== false && !allowEmptyNamepaths) {\n      const modeInfo = tagMissingRequiredTypeOrNamepath === true ? '' : ` in \"${mode}\" mode`;\n      report(`Tag @${tag.tag} must have either a type or namepath${modeInfo}.`, null, tag);\n\n      return;\n    }\n\n    // VALID TYPE\n    const hasTypePosition = mightHaveTypePosition === true && Boolean(tag.type);\n    if (hasTypePosition) {\n      validTypeParsing(tag.type);\n    }\n\n    // VALID NAME/NAMEPATH\n    const hasNameOrNamepathPosition = (\n      tagMustHaveNamePosition !== false ||\n      utils.tagMightHaveNamepath(tag.tag)\n    ) && Boolean(tag.name);\n\n    if (hasNameOrNamepathPosition) {\n      if (mode !== 'jsdoc' && tag.tag === 'template') {\n        utils.parseClosureTemplateTag(tag).forEach((namepath) => {\n          validNamepathParsing(namepath);\n        });\n      } else {\n        validNamepathParsing(tag.name, tag.tag);\n      }\n    }\n  });\n}, {\n  iterateAllJsdocs: true,\n  meta: {\n    docs: {\n      description: 'Requires all types to be valid JSDoc or Closure compiler types without syntax errors.',\n      url: 'https://github.com/gajus/eslint-plugin-jsdoc#eslint-plugin-jsdoc-rules-valid-types',\n    },\n    schema: [\n      {\n        additionalProperies: false,\n        properties: {\n          allowEmptyNamepaths: {\n            default: false,\n            type: 'boolean',\n          },\n        },\n        type: 'object',\n      },\n    ],\n    type: 'suggestion',\n  },\n});\n"],"file":"validTypes.js"}