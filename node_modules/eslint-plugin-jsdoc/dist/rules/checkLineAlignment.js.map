{"version":3,"sources":["../../src/rules/checkLineAlignment.js"],"names":["flow","commentFlow","align","commentAlign","indent","commentIndent","transforms","checkNotAlignedPerTag","utils","tag","spacerProps","contentProps","mightHaveNamepath","tagMightHaveNamepath","tokens","source","followedBySpace","idx","callbck","nextIndex","slice","some","spacerProp","innerIdx","contentProp","spacePropVal","ret","ok","contentPropVal","spacerPropVal","length","fix","forEach","hasSpace","contentPrp","setTag","reportJSDoc","checkAlignment","jsdoc","jsdocNode","report","transform","transformedJsdoc","comment","value","formatted","stringify","trimStart","fixer","replaceText","context","tags","applicableTags","options","includes","foundTags","getPresentTags","iterateAllJsdocs","meta","docs","description","url","fixable","schema","enum","type","additionalProperties","properties","items"],"mappings":"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","sourcesContent":["import {\n  transforms,\n} from 'comment-parser';\nimport iterateJsdoc from '../iterateJsdoc';\n\nconst {\n  flow: commentFlow,\n  align: commentAlign,\n  indent: commentIndent,\n} = transforms;\n\nconst checkNotAlignedPerTag = (utils, tag) => {\n  /*\n  start +\n  delimiter +\n  postDelimiter +\n  tag +\n  postTag +\n  type +\n  postType +\n  name +\n  postName +\n  description +\n  end\n   */\n  let spacerProps;\n  let contentProps;\n  const mightHaveNamepath = utils.tagMightHaveNamepath(tag.tag);\n  if (mightHaveNamepath) {\n    spacerProps = ['postDelimiter', 'postTag', 'postType', 'postName'];\n    contentProps = ['tag', 'type', 'name', 'description'];\n  } else {\n    spacerProps = ['postDelimiter', 'postTag', 'postType'];\n    contentProps = ['tag', 'type', 'description'];\n  }\n\n  const {tokens} = tag.source[0];\n\n  const followedBySpace = (idx, callbck) => {\n    const nextIndex = idx + 1;\n\n    return spacerProps.slice(nextIndex).some((spacerProp, innerIdx) => {\n      const contentProp = contentProps[nextIndex + innerIdx];\n\n      const spacePropVal = tokens[spacerProp];\n\n      const ret = spacePropVal;\n\n      if (callbck) {\n        callbck(!ret, contentProp);\n      }\n\n      return ret && (callbck || !contentProp);\n    });\n  };\n\n  // If checking alignment on multiple lines, need to check other `source`\n  //   items\n  // Go through `post*` spacing properties and exit to indicate problem if\n  //   extra spacing detected\n  const ok = !spacerProps.some((spacerProp, idx) => {\n    const contentProp = contentProps[idx];\n    const contentPropVal = tokens[contentProp];\n    const spacerPropVal = tokens[spacerProp];\n\n    // There will be extra alignment if...\n\n    // 1. There is extra whitespace within a single spacer segment OR\n    return spacerPropVal.length > 1 ||\n\n      // 2. There is a (single) space, no immediate content, and yet another\n      //     space is found subsequently (not separated by intervening content)\n      spacerPropVal && !contentPropVal && followedBySpace(idx);\n  });\n  if (ok) {\n    return;\n  }\n  const fix = () => {\n    spacerProps.forEach((spacerProp, idx) => {\n      const contentProp = contentProps[idx];\n      const contentPropVal = tokens[contentProp];\n\n      if (contentPropVal) {\n        tokens[spacerProp] = ' ';\n        followedBySpace(idx, (hasSpace, contentPrp) => {\n          if (hasSpace) {\n            tokens[contentPrp] = '';\n          }\n        });\n      } else {\n        tokens[spacerProp] = '';\n      }\n    });\n\n    utils.setTag(tag, tokens);\n  };\n  utils.reportJSDoc('Expected JSDoc block lines to not be aligned.', tag, fix, true);\n};\n\nconst checkAlignment = ({\n  indent,\n  jsdoc,\n  jsdocNode,\n  report,\n  utils,\n}) => {\n  const transform = commentFlow(commentAlign(), commentIndent(indent.length));\n  const transformedJsdoc = transform(jsdoc);\n\n  const comment = '/*' + jsdocNode.value + '*/';\n  const formatted = utils.stringify(transformedJsdoc)\n    .trimStart();\n\n  if (comment !== formatted) {\n    report(\n      'Expected JSDoc block lines to be aligned.',\n      (fixer) => {\n        return fixer.replaceText(jsdocNode, formatted);\n      },\n    );\n  }\n};\n\nexport default iterateJsdoc(({\n  indent,\n  jsdoc,\n  jsdocNode,\n  report,\n  context,\n  utils,\n}) => {\n  const {\n    tags: applicableTags = ['param', 'arg', 'argument', 'property', 'prop', 'returns', 'return'],\n  } = context.options[1] || {};\n\n  if (context.options[0] === 'always') {\n    // Skip if it contains only a single line.\n    if (!jsdocNode.value.includes('\\n')) {\n      return;\n    }\n\n    checkAlignment({\n      indent,\n      jsdoc,\n      jsdocNode,\n      report,\n      utils,\n    });\n\n    return;\n  }\n\n  const foundTags = utils.getPresentTags(applicableTags);\n  foundTags.forEach((tag) => {\n    checkNotAlignedPerTag(utils, tag);\n  });\n}, {\n  iterateAllJsdocs: true,\n  meta: {\n    docs: {\n      description: 'Reports invalid alignment of JSDoc block lines.',\n      url: 'https://github.com/gajus/eslint-plugin-jsdoc#eslint-plugin-jsdoc-rules-check-line-alignment',\n    },\n    fixable: 'whitespace',\n    schema: [\n      {\n        enum: ['always', 'never'],\n        type: 'string',\n      },\n      {\n        additionalProperties: false,\n        properties: {\n          tags: {\n            items: {\n              type: 'string',\n            },\n            type: 'array',\n          },\n        },\n        type: 'object',\n      },\n    ],\n    type: 'layout',\n  },\n});\n"],"file":"checkLineAlignment.js"}